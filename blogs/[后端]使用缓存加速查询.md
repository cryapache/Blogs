---
title: 使用缓存加速查询
tags:
  - Java
  - SpringBoot
  - Redis
  - Spring Cache
  - 缓存
  - 性能优化
draft: "false"
---

# 使用缓存加速查询

在高并发或高频查询场景下，直接访问数据库容易成为性能瓶颈。此时可引入 Redis 作为缓存层：优先从缓存读取数据，命中则直接返回；未命中再回源查询数据库，并将结果写入缓存，从而显著降低数据库压力、提升响应速度。

### CRUD流程变动

引入缓存后，传统的增删改查（CRUD）流程需要相应调整，以确保数据一致性：

- **查询**  
  先尝试从 Redis 获取数据。若命中缓存，直接返回；若未命中，则查询数据库，并将结果写入缓存供后续使用。

- **新增 / 修改  
  先操作数据库，成功后再更新或清除对应缓存。**推荐做法是清除缓存**（而非更新），让下一次查询自动重建缓存，避免因更新失败导致脏数据。

- **删除**  
  先删除数据库记录，再清除 Redis 中对应的缓存项。

>  ⚠️ 注意：缓存操作应放在数据库事务**提交之后**执行。否则，若事务回滚，缓存中可能残留无效数据，造成不一致。

### SpringBoot中使用注解提高开发效率

#### 添加依赖

```xml
<!-- 缓存框架 -->
<dependency>
	<groupId>org.springframework.boot</groupid>
	<artificatId>spring-boot-starter-cache</artificatId>
</dependency>

<!-- 缓存中间件，以redis为例 -->
<dependency>
	<groupId>org.springframework.boot</groupid>
	<artificatId>spring-boot-starter-data-redis</artificatId>
</dependency>

<!-- 数据库和相关操作的依赖 -->
```

#### 启用缓存

在启动类加上`@EnableCaching`注解

#### 常用注解

##### `@Cacheable` —— 查询时自动缓存
- 方法执行前先查缓存；
- 若存在，直接返回缓存值，**跳过方法体执行**；
- 若不存在，执行方法并将返回值存入缓存。
```java
@Service
public class UserService {

    @Cacheable(cacheNames = "users", key = "#id")
    public User getUserById(Long id) {
        return userRepository.findById(id).orElse(null);
    }
}
```
> Redis key 为 `cacheNames::id`



#####  `@CachePut` —— 更新时刷新缓存
- **总是执行方法体**；
- 将返回值写入缓存，用于更新已有缓存项。
```java
@CachePut(cacheNames = "users", key = "#user.id")
public User updateUser(User user) {
    return userRepository.save(user); // 总是执行
}
```
>  先更新 DB，再更新缓存



##### `@CacheEvict` —— 删除时清理缓存

```java
@CacheEvict(cacheNames = "users", key = "#id")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}

// 或清空整个缓存空间
@CacheEvict(cacheNames = "users", allEntries = true)
public void clearAllUsers() {
    userRepository.deleteAll();
}
```
